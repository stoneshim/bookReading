# Part 3. 도구


## Chapter 16. 버전관리와 브랜치 관리

> 핵심 메시지
> - 원 버전 규칙이 필요하다
> - 트렁크 기반으로 개발하는 조직일수록 성과가 좋을 가능성이 높다. (장수 개발 브랜치는 좋지 않다)

### 브랜치 관리
- 진행중인 작업은 브랜치와 비슷하다.
- "우리는 새로운 변경이 모든 테스트를 통과할 때까지 트렁크에 커밋하지 않습니다" ??
- `오래된 개발 브랜치를 병합하니 안정성이 떨어진다 > 병합은 위험하다 > 병합 프로세스를 어렵게 만들고 자주 못하게 한다`
- `많은 변경을 담은 기능을 배포하니 안정성이 떨어진다 > 배포는 위험하다 > 배포 프로세스를 어렵게 만들고 자주 못하게 한다`
- `인프라를 변경하니 안정성이 떨어진다 > 인프라 변경은 위험하다 > 인프라 변경 프로세스를 어렵게 만들고 자주 못하게 한다`

### 구글의 버전 관리
- 원-버전 규칙 : 여러개의 버전이 아예 없게 만든다? 이게 가능한가?
- 장수 브랜치는 금지
- `빌드 호라이즌` - production 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드하여 재배포해야 한다는 정책

> 적용해볼 것
> - 트렁크 기반 개발 : 테스트와 CI (트렁크에 합치는 것)
> - 빌드 호라이즌 적용해보면 어떨까?

## Chapter 17. Code Search

> 핵심 메시지
> - 이 심볼은 어디에 정의되어 있는가?
> - 이 메소드를 어디에서 사용하는가?
> - 이 코드는 언제 코드베이스에 추가되었나?
> - CPU 사이클을 얼마나 소모하는가?

### Code search를 이용하는 방법
- 검색 결과를 공유하기 좋음
- 코드의 옛 버전도 참조할 수 있음
- 무언가를 변경하기 전에 소스 콛를 읽고 더 잘 이해하기 위해
- 남들이 api를 어떻게 사용하는지 참고
- 디버깅 할때 특정 시점에 코드베이스의 정확한 상태를 찾고 탐색
- 코드 조각을 누가 언제 추가했는지 

### 웹 도구로 만들었음
- 대규모라서
- 특별한 설정없이 그냥 볼 수 있음
- 편집을 염두하지 않은 UI라 찾고 브라우징 하는데 최적화
- api를 통해 다른 도구에 통합 가능

### 설계, 트레이드오프
- 지연시간 증가와 생산성 손실이 선형관계가 아님
- `200 ms, 1초, 10초`
- 플래시 드라이브는 메모리보다 최소 10배 저렴, 100배 지연시간
- 검색의 특징 : 쿼리 독립적인 정보, 쿼리 의존적인 정보

### 생각해볼 것
> - github은 어떤것들이 안되나?
> - 우리는 검색 시스템이 필요할까?


## Chapter 18. 빌드 시스템과 빌드 철학
> 핵심 메시지
> - 빌드: 엔지니어들이 작성한 소스코드를 기계가 읽을 수 있는 바이너리로 변환
> - 속도와 정확성이 관건
> - 의존성 관리가 핵심기능이 된다

### 빌드 시스템의 종류
- 태스크 기반 빌드 시스템 (보통 스크립트 기반 빌드 시스템이라고 함)
  - Ant, Maven, Gradle
  - 병렬 실행이 어려움
  - 증분 빌드가 어려움
  - 스크립트가 디버깅이 필요할 정도로 복잡해질 수 있음
- 아티팩틑 기반 빌드 시스템 (보통 선언적 빌드 시스템이라고 함)
  - Bazel(Google), Pants(Twitter), Buck(FB)
  - 병렬실행, 증분 빌드 가능

### 전이의존성
- 전이의존성으로 생겼던 문제 경험
- 원 버전 규칙으로 어떻게 한다는 걸까?
- Maven의 재귀적 다운로드 말고, 명시적

### 생각해볼 것
> - 빌드 시스템과 CI 시스템
> - 우리도 선언적 빌드 시스템이 필요할까?

## Chapter 19. 구글의 코드 리뷰 도구 
> 핵심 메시지
> - 프로세스도 중요하지만 프로세스가 더 매끄럽게 운영되게끔 도와주는 도구 역시 중요한 역할을 한다.
> - 신뢰와 소통이 코드 리뷰 프로세스의 핵심입니다. 도구가 경험을 개선해줄 수는 있지만 대체하지는 못합니다.

### 생각해볼 문장들
- 코드 편집, 리뷰, 검색이 모두 가능한 Code Central이란 도구를 제작할까 고심하다가 결국 만들지 않기로 했습니다. 의도적으로 코드리뷰를 최우선으로 삼기로 했습니다.
- 변경 생성시 빌드, 테스트, 정적 분석과 스타일 검사 결과도 함께 보여준다. 자신의 변경 디프를 리뷰어의 관점에서 바라볼 수 있게 해준다.
- 디프를 보여줄 때 줄바꿈이나 공백과 상관없이 문자 수준으로 분해해 차이를 보여준다.
- 삭제, 추가됨이 아니라 이동으로 보여줌.
- 누구 차례 기능. 코드 리뷰에서는 항시 최소 한 명은 행동을 취해야 할 차례이다.

### 생각해볼 것
> - github pull request 방식의 리뷰는 편리한가? depth가 깊지 않은가?

## Chapter 20. 정적 분석

> 핵심 메시지
> - `정적분석`은 프로그램을 실행하지 않은 채로 소스 코드를 분석하여 버그나 안티패턴 등의 잠재적인 문제를 찾아내는 것을 말한다.
> - 모범 사례를 코드에 널리 배포하고, 최신 api를 이용하게 하며, 기술 부채를 막거나 줄여줍니다.
> - api 폐기 프로세스에서 없어서는 안될 도구이다 (역행이 일어나지 않게 막아준다)

### 효과적인 정적 분석의 특징
- 확장성
  - 코드량이 많아져도 결과를 제때 내놓을 수 있어야 한다.
  - 새로운 분석기법 하나를 추가하기 쉬워야 한다. 필요하면 새로운 분석을 추가하면서 전체 코드를 분석할 수 있어야 한다.
- 유용성
  - 정적 분석 경고를 해결하다가 새로운 버그가 생길 수 있다.
  - 새로 추가되는 코드에서 발생하는 경고에 더 집중하고 잘 동작중인 코드에 존재하던 이슈는 일반적으로 매우 중요할 때만 부각하고 수정한다.
  - 코드에 자동 반영할 수 있는 수정을 제공해서 개발자의 시간을 줄여준다.
  - 자동으로 수정할 수 있는 문제라면 뭐든 자동으로 해야 한다.

### 정적 분석을 적용하며 깨우친 핵심 교훈
- 개발자 행복에 집중하자
  - false positive가 낮은 분석도구만 사용한다 (10% 미만)
  - 피드백을 적극 요청하고 바로바로 조치한다
- 정적 분석을 개발자 워크플로에 반드시 끼워넣자
  - 커밋되는 모든 코드를 사전에 검토한다
  - 코드 리뷰가 분석결과를 제공하기에 이상적인 시점이다
- 사용자가 기여할 수 있도록 하자
  - 전문가들의 지식을 정적분석에 넣을 수 있게 하자

### 기타 중요한 것
- 분석결과에서 피드백을 바로 할 수 있게 했다 (Not useful)
- 진단메시지를 다듬어서 무엇이 왜 잘못되었고 어떻게 수정해야 하는지 설명하는게 가장 좋다.
- 정적분석 설정을 사용자별로 하지 않고 프로젝트별로 했다.
  - 사용자별 설정을 막아버렸다. 분석결과가 짜증난다는 원성이 쏟아졌다. 사용자별 설정을 되살리지 않았다.
  - 짜증나는 이유를 묻고 린터가 쏟아내는 버그와 False positive를 모두 찾아냈다.
  - 사용자별 설정은 버그를 감추고 원활한 피드백을 가로막는 결과로 이어진다
- IDE마다 흥망성쇠가 있어서 구글은 하나의 IDE를 강제하지 않는다.
  - IDE보다 코드리뷰가 분석결과를 보여주기 더 적합하지만, 한정한다면 IDE도 좋은 후보가 될수 있다.

### 생각해볼 것
> - 우리의 정적분석은
>   - 언제 어떤 것을 검사하나?
>   - 설정의 단위는 어떤가?
>   - 추가할 정적분석은 없을까? 추가한다면 어떻게 할 수 있을까?
>   - False positive, Not useful을 피드백할 수 있나?

## Chapter 21. 의존성 관리

> 핵심 메시지
> - 