# Part 3. 도구


## Chapter 16. 버전관리와 브랜치 관리

> 핵심 메시지
> - 원 버전 규칙이 필요하다
> - 트렁크 기반으로 개발하는 조직일수록 성과가 좋을 가능성이 높다. (장수 개발 브랜치는 좋지 않다)

### 브랜치 관리
- 진행중인 작업은 브랜치와 비슷하다.
- "우리는 새로운 변경이 모든 테스트를 통과할 때까지 트렁크에 커밋하지 않습니다" ??
- `오래된 개발 브랜치를 병합하니 안정성이 떨어진다 > 병합은 위험하다 > 병합 프로세스를 어렵게 만들고 자주 못하게 한다`
- `많은 변경을 담은 기능을 배포하니 안정성이 떨어진다 > 배포는 위험하다 > 배포 프로세스를 어렵게 만들고 자주 못하게 한다`
- `인프라를 변경하니 안정성이 떨어진다 > 인프라 변경은 위험하다 > 인프라 변경 프로세스를 어렵게 만들고 자주 못하게 한다`

### 구글의 버전 관리
- 원-버전 규칙 : 여러개의 버전이 아예 없게 만든다? 이게 가능한가?
- 장수 브랜치는 금지
- `빌드 호라이즌` - production 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드하여 재배포해야 한다는 정책

> 적용해볼 것
> - 트렁크 기반 개발 : 테스트와 CI (트렁크에 합치는 것)
> - 빌드 호라이즌 적용해보면 어떨까?

## Chapter 17. Code Search

> 핵심 메시지
> - 이 심볼은 어디에 정의되어 있는가?
> - 이 메소드를 어디에서 사용하는가?
> - 이 코드는 언제 코드베이스에 추가되었나?
> - CPU 사이클을 얼마나 소모하는가?

### Code search를 이용하는 방법
- 검색 결과를 공유하기 좋음
- 코드의 옛 버전도 참조할 수 있음
- 무언가를 변경하기 전에 소스 콛를 읽고 더 잘 이해하기 위해
- 남들이 api를 어떻게 사용하는지 참고
- 디버깅 할때 특정 시점에 코드베이스의 정확한 상태를 찾고 탐색
- 코드 조각을 누가 언제 추가했는지 

### 웹 도구로 만들었음
- 대규모라서
- 특별한 설정없이 그냥 볼 수 있음
- 편집을 염두하지 않은 UI라 찾고 브라우징 하는데 최적화
- api를 통해 다른 도구에 통합 가능

### 설계, 트레이드오프
- 지연시간 증가와 생산성 손실이 선형관계가 아님
- `200 ms, 1초, 10초`
- 플래시 드라이브는 메모리보다 최소 10배 저렴, 100배 지연시간
- 검색의 특징 : 쿼리 독립적인 정보, 쿼리 의존적인 정보

### 생각해볼 것
> - github은 어떤것들이 안되나?
> - 우리는 검색 시스템이 필요할까?


## Chapter 18. 빌드 시스템과 빌드 철학
> 핵심 메시지
> - 빌드: 엔지니어들이 작성한 소스코드를 기계가 읽을 수 있는 바이너리로 변환
> - 속도와 정확성이 관건
> - 의존성 관리가 핵심기능이 된다

### 빌드 시스템의 종류
- 태스크 기반 빌드 시스템 (보통 스크립트 기반 빌드 시스템이라고 함)
  - Ant, Maven, Gradle
  - 병렬 실행이 어려움
  - 증분 빌드가 어려움
  - 스크립트가 디버깅이 필요할 정도로 복잡해질 수 있음
- 아티팩틑 기반 빌드 시스템 (보통 선언적 빌드 시스템이라고 함)
  - Bazel(Google), Pants(Twitter), Buck(FB)
  - 병렬실행, 증분 빌드 가능

### 전이의존성
- 전이의존성으로 생겼던 문제 경험
- 원 버전 규칙으로 어떻게 한다는 걸까?
- Maven의 재귀적 다운로드 말고, 명시적

### 생각해볼 것
> - 빌드 시스템과 CI 시스템
> - 우리도 선언적 빌드 시스템이 필요할까?

## Chapter 19. 구글의 코드 리뷰 도구 
> 핵심 메시지
> - 프로세스도 중요하지만 프로세스가 더 매끄럽게 운영되게끔 도와주는 도구 역시 중요한 역할을 한다.
> - 신뢰와 소통이 코드 리뷰 프로세스의 핵심입니다. 도구가 경험을 개선해줄 수는 있지만 대체하지는 못합니다.

### 생각해볼 문장들
- 코드 편집, 리뷰, 검색이 모두 가능한 Code Central이란 도구를 제작할까 고심하다가 결국 만들지 않기로 했습니다. 의도적으로 코드리뷰를 최우선으로 삼기로 했습니다.
- 변경 생성시 빌드, 테스트, 정적 분석과 스타일 검사 결과도 함께 보여준다. 자신의 변경 디프를 리뷰어의 관점에서 바라볼 수 있게 해준다.
- 디프를 보여줄 때 줄바꿈이나 공백과 상관없이 문자 수준으로 분해해 차이를 보여준다.
- 삭제, 추가됨이 아니라 이동으로 보여줌.
- 누구 차례 기능. 코드 리뷰에서는 항시 최소 한 명은 행동을 취해야 할 차례이다.

### 생각해볼 것
> - github pull request 방식의 리뷰는 편리한가? depth가 깊지 않은가?

## Chapter 20. 정적 분석

> 핵심 메시지
> - `정적분석`은 프로그램을 실행하지 않은 채로 소스 코드를 분석하여 버그나 안티패턴 등의 잠재적인 문제를 찾아내는 것을 말한다.
> - 모범 사례를 코드에 널리 배포하고, 최신 api를 이용하게 하며, 기술 부채를 막거나 줄여줍니다.
> - api 폐기 프로세스에서 없어서는 안될 도구이다 (역행이 일어나지 않게 막아준다)

### 효과적인 정적 분석의 특징
- 확장성
  - 코드량이 많아져도 결과를 제때 내놓을 수 있어야 한다.
  - 새로운 분석기법 하나를 추가하기 쉬워야 한다. 필요하면 새로운 분석을 추가하면서 전체 코드를 분석할 수 있어야 한다.
- 유용성
  - 정적 분석 경고를 해결하다가 새로운 버그가 생길 수 있다.
  - 새로 추가되는 코드에서 발생하는 경고에 더 집중하고 잘 동작중인 코드에 존재하던 이슈는 일반적으로 매우 중요할 때만 부각하고 수정한다.
  - 코드에 자동 반영할 수 있는 수정을 제공해서 개발자의 시간을 줄여준다.
  - 자동으로 수정할 수 있는 문제라면 뭐든 자동으로 해야 한다.

### 정적 분석을 적용하며 깨우친 핵심 교훈
- 개발자 행복에 집중하자
  - false positive가 낮은 분석도구만 사용한다 (10% 미만)
  - 피드백을 적극 요청하고 바로바로 조치한다
- 정적 분석을 개발자 워크플로에 반드시 끼워넣자
  - 커밋되는 모든 코드를 사전에 검토한다
  - 코드 리뷰가 분석결과를 제공하기에 이상적인 시점이다
- 사용자가 기여할 수 있도록 하자
  - 전문가들의 지식을 정적분석에 넣을 수 있게 하자

### 기타 중요한 것
- 분석결과에서 피드백을 바로 할 수 있게 했다 (Not useful)
- 진단메시지를 다듬어서 무엇이 왜 잘못되었고 어떻게 수정해야 하는지 설명하는게 가장 좋다.
- 정적분석 설정을 사용자별로 하지 않고 프로젝트별로 했다.
  - 사용자별 설정을 막아버렸다. 분석결과가 짜증난다는 원성이 쏟아졌다. 사용자별 설정을 되살리지 않았다.
  - 짜증나는 이유를 묻고 린터가 쏟아내는 버그와 False positive를 모두 찾아냈다.
  - 사용자별 설정은 버그를 감추고 원활한 피드백을 가로막는 결과로 이어진다
- IDE마다 흥망성쇠가 있어서 구글은 하나의 IDE를 강제하지 않는다.
  - IDE보다 코드리뷰가 분석결과를 보여주기 더 적합하지만, 한정한다면 IDE도 좋은 후보가 될수 있다.

### 생각해볼 것
> - 우리의 정적분석은
>   - 언제 어떤 것을 검사하나?
>   - 설정의 단위는 어떤가?
>   - 추가할 정적분석은 없을까? 추가한다면 어떻게 할 수 있을까?
>   - False positive, Not useful을 피드백할 수 있나?

## Chapter 21. 의존성 관리

> 핵심 메시지
> - `의존성 관리` : 우가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일
> - 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴합니다.

### 언어별 의존성
- 자바는 의존성이 제공하는 심볼의 이름을 바꾸는 메커니즘이 잘 정립되어 있다. 
- 함수 수준에서는 이름을 고쳐 동작하게 할 수 있으나, 의존성 사이에 주고받는 타입에는 불가능하다.
- Go 언어는 대부분의 릴리즈에서 소스 코드가 호환되게 해주었지만 바이너리는 그렇지 않다. 빌드한 버전이 다른 바이너리끼리는 링크할 수 없다.

### 의존성을 임포트 할때 고려사항
- 여러분이 실행해 볼 수 있는 테스트가 딸려 있는 프로젝트인가?
- 테스트는 모두 통과하나?
- 의존성 제공자는 누구인가?
- 지향하는 호환성 정책은?
- 얼마나 인기있는 프로젝트인가?
- 언제까지 이용할 것인가?
- 파괴적인 변경이 얼마나 빈번하게 행해지고 있나?

### 의존성 관리 해법 네가지
- 변경 불가
- 유의적 버전
  - major, minor, patch 의 의미는 제공자 입장의 호환성 추정일 뿐이며, 아무것도 보장하지 않는다.
  - 근본적으로 자신의 api만 고려해서는 호환성에 대해 아무것도 증명할 수 없다.
  - 변경 자체만으로는 파괴적인지 아닌지 판단할 수 없다. '어떻게 씋이고 있는가'라는 맥락이 고려되어야 비로소 판단할 수 있다.
- 하나로 묶어 배포하기
  - 배포자 (distributor)
  - 리눅스 배포판
  - spring boot 방식
- 헤드에서 지내기
  - 소스관리정책인 트렁크 기반 개발을 업스트림 의존성에까지 적용한 모델
  - 항상 최신버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경은 허용하지 않음
  - 업스트림을 직접 개발하며, 단일 리포 정책이어야만 가능할 듯

> 핵심 정리
> - 의존성 추가는 공짜가 아니다. 의존성을 임포트할때 신중하게 결정해야 한다.
> - SemVer는 변경이 얼마나 위험할지를 '사람'이 '추정'하는, 간단하지만 정보가 일부 손실되는 표현법이다.
> - 테스트와 CI는 새로운 버전들이 잘 어울려 돌아가는지를 '실제로' 보여준다.

> 생각해 볼 것
> - gRPC등 SDK를 사용해야 의존성이 보인다. REST api는 보이지 않는다.

## Chapter 22. 대규모 변경

> 핵심 메시지
> - 대규모 변경(Large-Scale Change)은 논리적으로는 연관되어 있으나 현실적인 한계 때문에 원자적으로 서브밋할 수 없는 변경들의 집합
> - 보통 이런것들
>   - 코드베이스 전반을 훑는 분석 도구로 찾은 공통 안티패턴 청소
>   - 폐기 대상 api 호출 대체
>   - 컴파일러 업그레이드 등 저수준 인프라 개선사항 적용
>   - 옛 시스템에서 새로운 시스템으로 마이그레이션

### 기억할 것들
- LSC의 상당 비중을 인프라팀들이 수행합니다.
  - 인프라팀이 이미 잘 아는 전문지식을 다른 모든 팀에게 새로 배우도록 시키는 것은 비효율적
  - 합당한 보상 없이 할 일만 늘어나는 상황을 좋아할 사람은 없다
  - 대규모로 변경해야 할 시스템을 소유한 팀이 주도해야 변경을 완료하는데 유리하다
- 선결 조건들
  - 환경을 단순화해 일관성을 높여야 가능
  - CI 테스트가 잘 갖춰져 있어야 함
- 제품팀들이 자신들의 제품을 가장 잘 이해하듯이 라이브러리 인프라팀들은 인프라의 미묘한 부분까지 가장 잘 아는 사람들이다. 제품팀 사람들도 이 사실을 인정하고 인프라팀을 신뢰하는 일이 LSC를 조직에 연착륙시키는 중요한 첫 단추이다
- 코드 소유자는 자신의 소프트웨어가 어떻게 변경되는지를 이해해야 하지만, 그와 동시에 더 넓은 차원에서 이루어지는 LSC에 거부권을 행사할 수 없다는 사실도 받아들여야 한다
- 인력 투입량이 코드베이스보다 느리게 커져야 한다. 리포지터리가 커져도 사람이 개입하는 시간은 크게 달라지지 않아야 한다


## Chapter 23. 지속적 통합

> 핵심 메시지
> - 지속적 통합은 팀원들이 작업 결과를 자주 통합하는 소프트웨어 개발 방식이다. 통합할 때마다 자동빌드(테스트 포함)하여 통합 오류를 빠르게 찾아낸다.
> - 현대적 분산 애플리케이션에서 '자주 통합한다'는 말은 무슨 의미인가? 의존성이 함수 호출 스택에서 HTTP 요청이나 RPC까지 확장되는 것이다. 의존성들의 변경까지 모두 지속적으로 통합하는 걸 목표로 삼아야 한다.
> - 빠르게 진화하는 복잡한 생태계 전체를 지속적으로 조립하고 테스트하는 개발방식
> - CI 시스템은 무슨 테스트를 언제 실행해야 할지를 결정한다.
> - 규모가 커질 수록 CI 시스템이 더욱 필요해진다.
> - 빠르고 안정적인 테스트는 프리서브밋 단계에서, 느리고 덜 결정적인 테스트는 포스트 서브밋 단계에서 실행하도록 최적화 해야 한다.
> - 볼 수 있고 조치할 수 있는 피드백이 CI 시스템을 더 효율적으로 만들어 줍니다.

### CI, CB, CD
- CI = CB + CD
- CD : 지속해서 릴리즈 후보를 조립한 다음 다양한 환경에 차례로 승격시켜 테스트하는 활동.
- 릴리즈후보 : 자동화된 프로세스가 만든 서로 밀접하게 관련된 요소들로 구성된 배포 가능한 단위. 지속적 빌드를 통과한 코드, 설정정보, 기타 의존성들을 조합해 만든다.

### 지속적 테스트
- 프리서브밋
  - 빠르고 안정적인 테스트만 수행.
  - 작은 크기 테스트 또는 한 머신내 테스트로 한정
  - 변경이 이뤄지는 프로젝트로 한정하는 작은 테스트
  - (구글 경험) 프리서브밋 테스트를 통과한 95%가 이후 모든 테스트를 통과한다
- 포스트서브밋
- RC 생성 및 승격
- Production
  - 위 세개는 동일한 테스트를 수행한다.

## Chapter 24. 지속적 배포

> 핵심 메시지
> - 지속적으로 통합하고 테스트해야 한다.
> - 문제를 조기에 격리할 수 있도록 기능별로 플래그 가드를 두자
> - 단계적 출시를 활용하자
> - 기능별로 출시 비용과 창출 가치를 모니터링하여, 고객이 여전히 이용하며 충분한 가치를 제공하고 있는지 확인하자
> - Shift Left : CI, CD를 적용하여 모든 변경에 대한 판단을 더 빠르게 더 많은 테이터에 기초해 내리자
> - 적게 수정하여 빨리 자주 배포하면 각 릴리즈의 위험이 줄고 시장 변화에 적시에 대응할 수 있다.

### 지속적 배포 이디엄
- 자동화, 격리, 신뢰성, 단계적 출시, 데이터중심 의사결정
- 지속적 배포로 가는 중간 형태로 바꿔볼수는 있을 것이다. 실제로 배포하지는 않되 언제든 배포가 가능하도록 빌드하는 것이죠. 이렇게 하면 언젠가 더 자주 릴리스해도 되겠다는 자신감이 싹틀 것입니다.

### 기억할 것들
- 속도는 팀 스포츠다. 배포를 관리 가능한 조각으로 나눠야 한다. 
- 릴리스 비용이 늘고 위험이 커지면 본능적으로 릴리스 주기를 늦춰 안정성을 확보할 기간을 늘리려 한다. 멀리 보면 팀의 속도가 느려지고 팀과 고객 모두를 좌절시키는 선택이다. 비용을 줄이고, 규율을 강화하고 위험에 점진적으로 대응해야 한다.
- 가장 효과가 좋았던 투자는 마이크로서비스 아키텍처로의 전환이었다.
- 지속적인 릴리스를 안정적으로 수행하는 핵심은 엔지니어들이 모든 변경에 플래그 가드를 넣도록 하는 것이다.
- 릴리스 열차 갖추기.