# Part 3. 도구


## Chapter 16. 버전관리와 브랜치 관리

> 핵심 메시지
> - 원 버전 규칙이 필요하다
> - 트렁크 기반으로 개발하는 조직일수록 성과가 좋을 가능성이 높다. (장수 개발 브랜치는 좋지 않다)

### 브랜치 관리
- 진행중인 작업은 브랜치와 비슷하다.
- "우리는 새로운 변경이 모든 테스트를 통과할 때까지 트렁크에 커밋하지 않습니다" ??
- `오래된 개발 브랜치를 병합하니 안정성이 떨어진다 > 병합은 위험하다 > 병합 프로세스를 어렵게 만들고 자주 못하게 한다`
- `많은 변경을 담은 기능을 배포하니 안정성이 떨어진다 > 배포는 위험하다 > 배포 프로세스를 어렵게 만들고 자주 못하게 한다`
- `인프라를 변경하니 안정성이 떨어진다 > 인프라 변경은 위험하다 > 인프라 변경 프로세스를 어렵게 만들고 자주 못하게 한다`

### 구글의 버전 관리
- 원-버전 규칙 : 여러개의 버전이 아예 없게 만든다? 이게 가능한가?
- 장수 브랜치는 금지
- `빌드 호라이즌` - production 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드하여 재배포해야 한다는 정책

> 적용해볼 것
> - 트렁크 기반 개발 : 테스트와 CI (트렁크에 합치는 것)
> - 빌드 호라이즌 적용해보면 어떨까?

## Chapter 17. Code Search

> 핵심 메시지
> - 이 심볼은 어디에 정의되어 있는가?
> - 이 메소드를 어디에서 사용하는가?
> - 이 코드는 언제 코드베이스에 추가되었나?
> - CPU 사이클을 얼마나 소모하는가?

### Code search를 이용하는 방법
- 검색 결과를 공유하기 좋음
- 코드의 옛 버전도 참조할 수 있음
- 무언가를 변경하기 전에 소스 콛를 읽고 더 잘 이해하기 위해
- 남들이 api를 어떻게 사용하는지 참고
- 디버깅 할때 특정 시점에 코드베이스의 정확한 상태를 찾고 탐색
- 코드 조각을 누가 언제 추가했는지 

### 웹 도구로 만들었음
- 대규모라서
- 특별한 설정없이 그냥 볼 수 있음
- 편집을 염두하지 않은 UI라 찾고 브라우징 하는데 최적화
- api를 통해 다른 도구에 통합 가능

### 설계, 트레이드오프
- 지연시간 증가와 생산성 손실이 선형관계가 아님
- `200 ms, 1초, 10초`
- 플래시 드라이브는 메모리보다 최소 10배 저렴, 100배 지연시간
- 검색의 특징 : 쿼리 독립적인 정보, 쿼리 의존적인 정보

### 생각해볼 것
> - github은 어떤것들이 안되나?
> - 우리는 검색 시스템이 필요할까?


## Chapter 18. 빌드 시스템과 빌드 철학
> 핵심 메시지
> - 빌드: 엔지니어들이 작성한 소스코드를 기계가 읽을 수 있는 바이너리로 변환
> - 속도와 정확성이 관건
> - 의존성 관리가 핵심기능이 된다

### 빌드 시스템의 종류
- 태스크 기반 빌드 시스템 (보통 스크립트 기반 빌드 시스템이라고 함)
  - Ant, Maven, Gradle
  - 병렬 실행이 어려움
  - 증분 빌드가 어려움
  - 스크립트가 디버깅이 필요할 정도로 복잡해질 수 있음
- 아티팩틑 기반 빌드 시스템 (보통 선언적 빌드 시스템이라고 함)
  - Bazel(Google), Pants(Twitter), Buck(FB)
  - 병렬실행, 증분 빌드 가능

### 전이의존성
- 전이의존성으로 생겼던 문제 경험
- 원 버전 규칙으로 어떻게 한다는 걸까?
- Maven의 재귀적 다운로드 말고, 명시적

### 생각해볼 것
> - 빌드 시스템과 CI 시스템
> - 우리도 선언적 빌드 시스템이 필요할까?