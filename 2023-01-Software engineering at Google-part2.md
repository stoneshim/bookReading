# Part 2.  프로세스

## Chapter 8. 스타일 가이드와 규칙
> 핵심 메시지
> - rule(규칙) vs guidance(지침)
> - rule : 언어별 style-guide
> - guidance : 언어별 primer
> - 코드의 `지속가능성`을 높이는 것이 목적이다

### Rule의 필요성
- 좋은 행동을 장려하고 나쁜 행동을 억제하는 것 
- 좋고 나쁨의 기준이 무엇인가? 조직이 추구하는 가치
  - `규모와 시간 양쪽 측면에서 탄력적인 엔지니어링 환경이 지속되도록 하는 것`
- 코딩 어휘가 통일되면 엔지니어들은 `형식`보다 `내용`에 집중할 수 있다

### 규칙 만들기
- 무슨 규칙이 필요하지? 가 아니라 어떤 목표를 이루려 하지?
- 자율성과 규칙의 트레이드 오프
  - 내적동기를 이끄는 요소 : 자율성, 숙련, 의미
- 1. 규칙의 양을 최소화 한다
  - 자명한 규칙 배제
- 2. 읽는 사람에게 맞춘다
  - `쓰기에 간편한`보다 `읽기에 간단한`쪽에 가치를 둔다
  - 우리 목적은 `현 위치에서 추론하기` 입니다
- 3. 일관되어야 한다
  - 모든 지역별 연구소의 인터페이스가 동일하다 > 사소한 설정때문에 시간을 허비하는 일을 없앤다
  - 일관성 vs 자율성
  - 일관성이 주는 이점은 우리가 잃게되는 자유의 가치보다 훨씬 크다. 엔지니어가 더 많은 일을 적은 노력으로 수행할 수 있게 된다
  - 일관성이 규모를 확장하기 쉽게 도와준다 (도구 활용)
- 4. 실수를 유발하는 구조를 피한다
  - 구글은 코드베이스가 특정 전문가의 전유물이 아닌 모든 엔지니어의 작업 공간이 되길 원한다
- 5. 꼭 필요하면 예외를 허용한다
  - 일관성과 가독성을 희생해서라도 성능을 끌어올려야 할 때가 있다

### style-guide
- 어떤 내용이 포함되어야 하나?
  - 위험을 피하기 위한 규칙
  - 모범 사례를 적용하기 위한 규칙 : 주석, 네이밍, 포맷팅
  - 일관성을 보장하기 위한 규칙
  - 그리고, 이러한 결정 뒷받침하는 근거
- 일관성 
  - 파키슨의 사소함의 법칙 : 중요한 사안을 고민하는데는 아주 적은 시간만 들이면서 사소한 일에는 필요 이상의 시간과 노력을 들이는 현상. (별 차이가 없어서 더 합의를 못하는 팀 vs 별 차이가 없으니 그냥 정하자는 팀)
  - 하나를 선택함으로써 끝없는 논쟁에서 벗어나 더 중요한 일로 시선을 돌릴 수 있게 했다

### 규칙 적용하기
- 규칙을 강제하는 방법으로는 `교육과 훈련을 통한 사회적인 방법`과 `도구를 이용한 기술적인 방법`이 있다
- 도구활용은 확장성을 도와주지만, 사회적인 문제를 기술적인 문제로 해결하려 해서는 안된다.

> 생각해볼 것들
> - 우리는 spring api java style-guide를 만들어 보면 어떨까?
> - 구글의 style-guide (java, go, python) 공부해보기 어떨까? 
> - Error prone을 이용해 규칙 적용을 도구화 할 수 있을까?
> - 삼성에서 전체 적용되는 룰을 만들 수 있을까? 회사가 너무 커지지 않았을 때부터 만들어 온걸까?

## Chapter 9. 코드리뷰
> 핵심 메시지
> - 버그가 코드베이스로 침투하기 전에 잡아낸다
> - 심리적인 이점들은 시간이 흐르고 조직 규모가 커지면 큰 혜택이 된다

### 코드는 부채다
- 없어서는 안될 부채이긴 하겠으나 존재만으로 어느 순간 누군가에게 유지보수해야 할 대상이 되어버린다
- 마치 비행기의 연료처럼 비행기를 띄우려면 반드시 필요하지만, 그 자체가 하중을 늘려 부담으로 작용히죠
- 코드 리뷰는 전에 내린 설계를 번복하거나 재논의하는 자리여서는 안됩니다. 설계를 결정하는 데는 보통 시간이 걸립니다
- 전혀 새로운 코드를 리뷰하는 일이 뜬금없이 생겨서는 안 되듯이, 코드 리뷰 과정 자체를 기존 결정을 다시 논의할 기회로 보아서는 안됩니다

### 세가지 측면의 리뷰
- 다른 엔지니어 : 코드가 정확하고 유효한지
- 코드 소유자 : 승인 - 유지보수할 수 있을지, 기술부채를 안겨주는지
- 가독성 인증자 : 가독성 승인 (스타일 가이드에 맞는지)

> 구글에서는 Owners 파일이 왜 필요할까?
> - git 프로젝트 owner가 owner 아닌가? 단일 repo가 하나의 프로젝트란 뜻인가?
> - 한 프로젝트 내에서도 소유권을 나눠야 할 경우가 있나?

### 생각할 거리
- 코드리뷰는 코드의 유지보수와, 읽는속도 최적화와 쓰는속도의 트레이드오프
- 리뷰 프로세스를 날렵하게(확장성있게) 유지하기 위한 장치
  - 작은 변경, 빠른피드백, 최소리뷰어, 자동화
- 잘못되었다고 가정하기 전에 그렇게 처리하게 된 이유가 무엇인지부터 물어보는 것

> 생각해볼 것들
> - 우리가 부족한것들은 무엇이 있을까?

## Chapter 10. 문서자료
> 핵심 메시지
> - 문서자료는 시간이 흐르고 조직 규모가 커질수록 중요해진다
> - 문서자료 변경도 기존 개발자 워크플로에 통합되어야 한다 (문서자료를 코드처럼 취급)
> - 하나의 문서는 하나의 목적에 집중해야 한다
> - 문서자료는 자신이 아니라 독자를 위해 써야 한다 

### 문서자료란
- 엔지니어가 작업을 끝마치기 위해 작성해야 하는 모든 부수적인 텍스트

### 문서자료는 코드와 같다
- 꼭 따라야 하는 내부 정책과 규칙이 있다
- 버전 관리 시스템에 등록해 관리해야 한다
- 관리 책임자를 명시해야 한다
- 변경 시 (문서자료가 설명하는 코드와 함께) 리뷰를 거쳐야 한다
- 버그를 추적하듯 문제를 추적해야 한다
- 주기적으로 평가(혹은 테스트)를 받아야 한다
- 정확성이나 최신 정보 반영 여부 등을 측정해야 한다

### 위키에서 git으로
- 위키의 한계
  - 소유자가 없어서 많은 페이지가 오래된 정보를 그대로 담고 있다
  - 틀린 내용을 바로잡아줄 사람들이 없다
- 반대 의견
  - 정보를 자유롭게 올리지 못하고, 문서화 하는 장벽이 높아져서 문서자료 품질이 떨어질 것이다
- 효과
  - 개선됐다
  - 마크다운을 표준 문서 서식 언으로 도입했다
  - 코드안에 문서자료를 삽입해주는 프레임워크 g3doc (소스코드와 문서를 한 화면에서 볼 수 있다)
  - 문서자료를 코드와 비슷한 방식으로 유지보수한다 (버그 리포팅, CL에 문서자료 수정까지 포함, 리뷰받기) > 새로운 프로세스를 만들지 않고 기존 개발자 워크플로에 녹였다

### 독자 유형
- 경험수준
- 도메인 지식
- 목적
- 탐색자 vs 배회자
- `문서를 짧게 쓰려면 때로는 모든 정보를 담아 길게 쓴 다음 간명하게 편집하고 중복된 정보를 삭제하는 과정을 거쳐야 한다`

### 문서 자료 유형
- 주석 - api 주석, 구현 주석
- 설계문서
  - `중요한 프로젝트에 착수하기 전에 설계 문서부터 승인받아야 한다`
  - 표준 설계 문서 템플릿은 보안, 국제화, 스토리지 요구사항, 개인정보 보호 등 다양한 측면을 고려하도록 유도
  - `설계의 목표, 구현전략, 설계상의 핵심 선택들과 관련한 트레이드 오프를 명시`
- 튜토리얼
- 개념 설명 문서자료 : 주석으로는 부족한 경우 api나 시스템의 개요를 알려주는 개념 문서
- 랜딩 페이지

> 생각해볼 것들
> - 문서화에 우리가 적용해볼 것들은?
> - 위키에서 git으로
> - 소스트리에 문서 디렉토리를 추가하고 리뷰 받자
> - 스프린트 계획과 CL에 문서화를 넣자


## Chapter 11. 테스트 개요
> 핵심 메시지
> - 2000년대 초부터 소프트웨어 복잡도에 대응하기 위해 테스트 방식을 극적으로 진화시켰다
> - 테스트체계는 소프트웨어 개발의 핵심역량이다

### 테스트의 필요성
- 테스트가 갖을 수 있는 문제들
  - 느리기 비결정적임
  - 쉽게 깨짐
  - 명확하지 않음
- 나쁜 테스트는 아예 없는것만 못하다
- <구글 웹서버> 추가 기능의 80%가 버그로 롤백 (Change Failure Rate)
- `대부분의 소프트웨어는 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다`
- 그래서 테스트에서의 해법은 단 하나. 바로 '자동화' 뿐이다

### 건실한 자동화 테스트 문화
- 모두가 테스트를 작성하고 공유하도록 장려한다
- 테스트들을 정기적으로 실행한다
- 테스트가 실패하면 바로 바로 조치하도록 권장한다

### 테스트 코드가 주는 혜택
- 디버깅 감소
- 자신있게 변경
- 테스트 코드 자체가 더 나은 문서자료
- 더 단순한 리뷰
- 사려깊은 설계
- 고품질의 릴리즈를 빠르게

### 테스트 스위트 설계하기
- 테스트 케이스에는 두 가지 독립된 요소가 있다 : `크기` 와 `범위`
- 유연성 vs 느림 또는 비결정적
- 크기 : 테스트 케이스 하나를 실행하는 데 필요한 자원
  - 작은 테스트 : 하나의 프로세스에서 실행. 블로킹 호출 금지 (디스크, 네트워크)
  - 중간 테스트 : 한대의 기기에서 수행. 외부통신 금지. 여러프로세스 가능
  - 큰 테스트 : 여러 대의 기기 활용. 한정적으로만 사용. 설정을 검증. 개발 워크플로에서 분리 (빌드나 릴리즈 때만 수행)
  - 테스트 크기와 무관한 공통 특성
    - 밀폐되어야 한다.
    - 확인하려는 행위를 수행하는데 필요한 정보'만'을 포함해야 한다.
    - 테스트 자체를 검사해주는 테스트는 따로 없으므로 정확성이라는 중요한 검사는 사람이 직접 해야 한다. 따라서 복잡하지 않아야 한다.
- 범위 : 검증하려는 특정한 코드 경로
  - 단위테스트, 통합테스트, 기능테스트(종단간 테스트)
  - 딱히 실행할 수 없는 상황이 아니라면 실제 의존성을 끊지 않는 편을 선호한다.

* `테스트 대역은 강한 의존성을 가벼운 인프로세스 의존성으로 대체해주는 수단`
* `의도적으로 실패 상황을 만드는 테스트가 중요하다`
* `코드 커버리지는 작은 테스트에서만 측정하길 권한다. 큰 테스트는 커버리지 인플레이션을 일으킨다`
* `커버리지보다는 검사해야할 행위에 집중하자`

### 구글 의 특징
- 모든 코드를 모노리포에서 관리
- 매주 약 2천 5백만 라인이 변경
- 리포지터리 브랜치를 사용하는 팀이 거의 없다. 모든 변경은 헤드에 직접 커밋되어 변경즉시 모두가 볼 수 있다

### 구글 자동화 테스트를 전사에 뿌리내리게 한 원동력
- 오리엔테이션 수업
- 테스트 인증 프로그램 -> 자동화 방식으로 대체됨
- 화장실에서도 테스트

### 자동 테스트의 한계
- 모든 종류의 테스트를 다 자동화할 수는 없습니다 (검색품질 테스트)
- `탐색적 테스팅` : 검사대상을 마치 고장내야할 퍼즐로 취급

> 생각해볼 것들
> - ㅁㅁㅁ

## Chapter 12. 단위 테스트
> 핵심 메시지
> - 테스트의 목적은 1) 버그 예방, 2) 엔지니어의 생산성 향상

### 단위테스트는
- 빠르고 결정적이어서 수시로 수행하며 피드백 얻을 수 있다
- 작성하기 쉽다
- 커버리지를 높이기 좋다
- 실패시 원인 파악이 쉽다
- 문서자료, 예제코드 역할을 해준다

### 테스트 유지보수의 문제 두가지
- 깨지기 쉬운 테스트 (Brittle)
- 불명확한 테스트 (Unclear)

### 깨지기 쉬운 테스트를 예방하는 법
- Brittle test : 실제로는 버그가 없는 변경 때문에 실패하는 테스트
- 변하지 않는 테스트로 만들기 위해 노력하자
  - 순수 리팩터링, 새로운 기능 추가, 버그 수정 : 기존 테스트를 손볼일 없어야 함
  - 행위 변경 -> 시스템이 한 약속을 '의도적으로' 변경하는 케이스
- 공개 API를 이용해 테스트 (Private method는 테스트하지 말라)
  - 내부 구현을 위한 코드가 아닌 공개 API를 호출
  - 테스트가 시스템을 사용자와 똑같은 방식으로 사용하는 것
  - 소수의 다른 클래스를 보조하는 용도의 클래스는 독립 단위가 아니다
  - 소요자의 통제없이 누구나 접근할 수 있는 클래스는 직접 테스트해야하는 단위
  - 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스도 테스트 단위
- 상호작용이 아니라 상태를 테스트하자
  - 상태 테스트 vs 상호작용 테스트 -> mockito가 하는 것
  - 그래서 우리는 진짜 객체가 빠르고 결정적이라면 테스트 대역을 지양하고 진짜 객체를 사용

### 명확한 테스트 작성하기
- 명확한 테스트 : 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트
- 완전하고 간결하게
  - 완전한 테스트 : 결과에 도달하기까지의 논리를 읽는이가 이해하는데 필요한 모든 정보를 본문에 담고 있는 테스트
  - 간결한 테스트 : 관련 없는 정보를 포함하지 않는 테스트
- 메서드가 아니라 행위를 테스트하자
  - 테스트 구조를 대상 코드의 구조와 일치시킬 필요가 있나? (메서드 하나에 테스트 메서드 하나)
  - given/when/then을 활용
  - 메서드와 행위는 다대다 관계
  - 사소하지 않은 메서드는 대부분 여러가지 행위를 담당하며,
  - 어떤 행위는 여러 메서드를 연계해야 완성된다
  - 테스트의 구조는 행위가 부각되도록 (메서드 이름 > given/when/then > 실제 코드)
  - 테스트 이름은 검사하는 행위에 어울리게 짓자
    - 제품 코드보다 더 길게 상세하게 지어도 괜찮다.
    - 좋은 전략이 없으면 should로 시작하는 이름
  - 테스트에 논리를 넣지 말자
    - 연산자, 반복문, 조건문 등
    - 테스트 코드에서는 스마트한 로직보다 직설적인 코드를 고집해야 한다
  - 실패 메시지를 명확하게 작성하자
    - 원하는 결과, 실제 결과, 이때 건네진 입력값


### DRY가 아니라 DAMP!
- Don't Repeat Yourself
- Descriptive And Meaningful Phrase
- 단순하고 명료하게만 만들어준다면 테스트에서 다소의 중복은 괜찮습니다
- 테스트에서의 리팩터링은 반복을 줄이는 게 아니라 더 서술적이고 의미있게 하는 방향으로 이루어져야 한다


## Chapter 13. 테스트 대역
> 핵심 메시지
> - 테스트 대역은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다
> - 테스트 대역보다는 실제 구현을 사용하자
> - 실제 구현을 사용할 수 없을 때는 가짜 객체가 최선일 때가 많다

### 테스트 대역이 소프트웨어 개발에 미치는 영향
- 테스트 용이성 (testability)
  - 테스트하기 쉽게 설계되지 않았다면 테스트 대역을 쓰기 위해 많이 리팩터링 해야 함
- 적용 가능성 (adaptability)
  - 잘못 사용하면 오히려 깨지기 쉽고 복잡하고 효율도 나쁜 테스트가 된다
- 충실성 (fidelity)
  - 테스트에 활용하려면 대역은 일반적으로 실제보다 훨씬 단순해야 한다
  - 테스트 대역을 사용하는 단위테스트들만으로 채우지 못하는 부분은 실제 구현을 이용하는 더 큰 범위의 테스트로 보완해줘야 한다

### 대표적인 테스트 대역
- Dummy Object : 내부 구현이 없는 테스트 더블. 파라미터로 전달은 되지만 사용되지 않는 경우
- Fake Object : 원래 객체의 단순화된 버전. (인메모리 repository). 실제 객체의 기능이 추가되면 곤란해짐
- Stub : 미리 정해진 대답을 제공하는 객체. 테스트를 위해 프로그래밍된것 외에는 응답하지 않음
- Spy : Stub + 호출 기록
- Mock : 상호작용 테스트
- https://martinfowler.com/bliki/TestDouble.html

### 실제 구현을 사용할지 결정하기
- 실행시간 : 너무 느리다 싶을때 테스트 대역을 고려하자.
  - 너무 느릴때 고려할 수 있는 다른 기법 : 테스트 병렬화, 빌드 도구 (Bazel) - 캐싱
- 결정성 : 불규칙한 결과가 나올 때
  - 통제할 수 없는 외부서비스에 의존하는 코드 -> 테스트 대역 또는 밀폐된 인스턴스(중간 크기 테스트)
- 의존성 생성 : 대역으로 대체할 수 있도록 미리 유연하개 개발되어 있어야 한다.

### Fake Object
- 실제 구현을 이용할 수 없을때 Fake object가 최선을 경우가 많다
- 실제 객체의 행위가 변경될 때마다 발맞춰서 갱신해야 하므로 유지보수도 신경써야 한다
- 가짜 객체 작성과 유지보수는 실제 구현을 담당하는 팀이 맡아야 한다
- 가짜 객체도 테스트가 있어야 한다

### Stub의 위험성
- 불명확해진다 - 왜 값을 그렇게 정했는지 이해하기 어렵다
- 깨지기 쉬워진다 - SUT 내부가 달라지면 테스트가 달라질 수 있다(?)
- 테스트 효과가 감소한다 - 실제 구현과 똑같이 동작하는지 보장할 방법이 없다
- Stub이 적합한 경우
  - `특정 오류를 일으키게 해야 할때`

### 상호작용 테스트의 위험
- SUT가 특정 함수를 호출했는지만 알려줄 뿐, 올바르게 작동하는지 말해주지 않는다
- SUT의 상세 구현 방식을 활용한다
- 상호작용 테스트가 적합한 경우
  - 상태변경 함수를 테스트 하는 경우 (idempotent하지 않은 함수 - sendmail, log)

## Chapter 14. 더 큰 테스트
> 핵심 메시지
> - 큰 테스트는 단위 테스트가 다루지 못하는 문제를 책임진다
> - SUT, 데이터, 검증방법 으로 구성된다

### 단위 테스트가 손대기 어려운 영역
- 부정확한 테스트 대역
  - 엔지니어가 실제 의존 대상까지 담당하는 경우는 많지 않다. 의존 대상의 실제 동작을 잘못 이해하고 있을 수 있다
- 설정 문제
  - 설정파일에 문제가 있는지 검증하기 어렵다
  - 설정도 코드처럼 버전 관리를 해야 한다
- 과부하시 나타나는 문제
- 예기치 못한 동작, 입력, 부작용
  - `단위 테스트의 범위는 작성자의 상상력에 갇히게 된다`
- 창발적 행위와 진공효과
  - 혼돈으로 가득한 현실과는 동떨어진 '진공상태를 가정'하고 문제를 푸는 격이다
  - 실험실 환경에서 동작하지만 필드에서 동작하지 않는 제품'

### 더 큰 테스트를 만들지 않는 이유
- 결정성, 속도, 확장성
- 소유권 문제 : 큰 테스트는 다수의 단위에 걸쳐있다. 누구의 책임인가?
- 표준화 문제 : 큰 테스트를 만들고 수행하는 인프라, 프레임워크가 각각 다르다

### 더 큰 테스트의 구조
1. 테스트 대상 시스템 확보
  - 밀폐성과 충실성
  - 단일 프로세스 SUT
  - 단일 머신 SUT : 프로덕션 실행설정을 그대로 사용
  - 다중 머신 SUT :
    - 공유환경 (Staging, Production)
    - 하이브리드 : 일부는 독립적으로, 다른 일부는 공유환경
    - 기록/재생 프록시 : 기록모드 테스트시 기록, 재생모드 테스트시 재생
      - 새로운 테스트를 추가할때, 클라이언트 행위가 달라질 때 새로 기록해야 함
2. 필요한 테스트 데이터 준비
  - 시드 데이터 : 테스트 개시 시점의 SUT 상태를 반영하여 SUT를 사전 초기화 해주는 데이터
  - 테스트 트래픽 : 테스트 수행 과정에서 SUT 로 보내는 데이터
  - 데이터 생성 방식
    - 손수 만들기
    - (프로덕션 시스템에서) 복사해서 사용하기
    - (프로덕션 시스템에서) 샘플링해서 사용하기
      - 테스트 커버리지를 극대화할 수 있는 최소한의 데이터만 추출해내는 기술을 '스마트 샘플링'이라 한다
3. 대상 시스템을 이용해 동작 수행
4. 행위 검증

### 테스트의 유형
- 기능 테스트
  - SUT : 밀폐된 단일머신 또는 격리된 클라우드
  - 데이터 : 수동 생성
  - 검증방식 : 단정문
- 성능, 부하, 스트레스 테스트
  - SUT : 격리된 클라우드
  - 데이터 : 수동생성 또는 프로덕션 환경에서 복사
  - 검증방식 : 차이 비교
- 배포 설정 테스트
  - SUT : 밀폐된 단일머신 또는 격리된 클라우드
  - 데이터 : 없음
  - 검증방식 : 단정문 (비정상 종료는 하지 않음) (보통 잘 구동되면 테스트 통과)
- A/B 테스트
  - SUT : 두개의 격리된 클라우드
  - 데이터 : 프로덕션 환경에서 복사 또는 샘플링한 데이터
  - 검증방식 : A/B 차이 비교
- 사용자 인수 테스트
  - SUT : 밀폐된 단일머신 또는 격리된 클라우드
  - 데이터 : 수동생성
  - 검증방식 : 단정문 (Cucumber, RSpec)
  - 구글은 자동화된 UAT를 잘 활용하지 않음. 
- 프로버와 카나리 분석
  - SUT : 프로덕션에 배포
  - 데이터 : 프로덕션에서 수집
  - 검증방식 : 단정문과 (지표상의) A/B 차이
  - Prober (무인 우주 탐사선)은 프로덕션 환경을 대상으로 단정문을 수행하는 기능테스트
    - 잘 알려진 결정적인 읽기 전용 동작이 검증 대상
  - Canary analysis 신버전을 조금씩 대체해 가면서 신버전과 기존버전 모두를 대상으로 Prober를 수행

> 적용해볼 것
> - Prober 가 필요하지 않나?
> - 테스트 데이터를 프로덕션에서 샘플링해도 괜찮을까?
> - 기록/재생 프록시를 사용해볼 수 있을까?


## Chapter 15. 폐기
> 핵심 메시지
> - 소프트웨어 시템이 존재하는 한 유지보수 비용은 계속 발생하므로 제거하는 비용과 저울질 해봐야 합니다.
> - 폐기비용을 생각하면 새로운 시스템으로 교체하기보다 기존 시스템을 개선하는 편이 일반적으로 더 저렴합니다.

### Deprecation
- 이주를 순차적으로 진행하여 궁극적으로는 낡은 시스템을 완전히 걷어내는 과정을 폐기라 한다
- 제대로 폐기시키지 못하면 시스템을 방치할 때보다 더 큰 비용을 치를 수 있다.
- 시스템 설계단계에서부터 계획을 세워두면 수월하다.

### 폐기시키는 이유
- 코드는 자산이 아니라 부채다
- 코드는 가치를 창출하지 않는다. 사용자의 요구에 부합하는 기능은 자산이다.
- 오래된 시스템을 제거하는 데는 실제로 눈에 보이는 비용이 드는 반면, 아무것도 하지 않고 시스템을 방치해서 새어나가는 비용은 눈에 잘 띄지 않는다.
- '언젠가는 폐기하게 될 시스템을 설계한다'라는 개념이 소프트웨어 엔지니어링 시각에서는 생소할 수 있지만 다른 엔지니어링 분야에서는 흔한 일이다.
  - 내 제품의 고객이 잠재적인 대체품으로 이주하기가 얼마나 쉬울까?
  - 내 시스템을 한 부분씩 점진적으로 교체하려면 어떻게 해야할까?

### 권고 폐기 (advisory deprecation)
- 기한이 없고 조직에서도 우선순위가 높지 않은 경우
- 사용자에게 주는 혜택이 매우 클 때 효과가 좋음. (정말 좋다 정도가 아니라 혁신적인 수준)
- 자가 이주 도구를 제공하는 정도만으로도 이주가 빠르게 이루어진다.
- '제발 새로운 시스템을 사용해주세요'라고 아무리 외쳐도 기존 시스템을 사용하고 있는 곳이 많다면 그냥 계속해서 기존 시스템을 이용하려는 경향이 크다.

### 강제 폐기 (compulsory deprecation)
- 낡은 시스템의 지원 종료일을 못 박는 형태
- 인력 지원 없이 강제 폐기를 밀어붙이면 고객 팀들으 ㅣ반발을 사서 폐기 작업이 지연될 수 있다.
- 강제 폐기를 시도하려면 반드시 전문 팀을 꾸려 적극적으로 지원하라

### 폐기 프로세스 관리
- 프로세스 소유자
  - 폐기 업무를 시스템 이용자들에게 절대 떠넘기지 마세요
  - 소유자 없는 폐기는 모든 낡은 시스템들을 무한정 유지하겠다는 선언과 같으며, 이용자에게 떠넘기면 권고 폐기와 같아져서 결코 말끔하게 끝나지 않을 것입니다. 
  - 책임자를 두어 폐기에 필요한 전문지식을 집중시키면 집행 비용을 더 투명하게 알 수 있어서 실제로도 비용이 절감됩니다.
  - 버려진 프로젝트들이 문제를 일으킨다. 이런 프로젝트에는 폐기 전문가를 배정하여 하루빨리 제거해야 한다.
- 마일스톤
  - 구축 프로젝트는 일반적으로 마일스톤이 명확하다. 대조적으로 폐기 프로젝트에서는 낡은 시스템을 완전히 제거하는 것만이 유일한 마일스톤이라고 생각하는 경향이 있다.
  - 핵심 컴포넌트들을 하나씩 제거하는 걸 점진적 마일스톤으로 삼으면 효과가 좋더라.
- 폐기 도구
  - 발견 : 폐기시킬 라이브러리를 누가 이용 중인지를 코드를 돌려보지 않아도 알아낸다. (Code Search)
  - 마이그레이션 : 대규모 변경 프로세스와 도구
  - 퇴행 방지 :정적분석 활용 @deprecated 애너테이션 감지

> 적용해볼 것
> - Code Search
> - 폐기 마일스톤 (ORS)