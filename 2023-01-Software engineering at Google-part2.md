# Part 2.  프로세스

## Chapter 8. 스타일 가이드와 규칙
> 핵심 메시지
> - rule(규칙) vs guidance(지침)
> - rule : 언어별 style-guide
> - guidance : 언어별 primer
> - 코드의 `지속가능성`을 높이는 것이 목적이다

### Rule의 필요성
- 좋은 행동을 장려하고 나쁜 행동을 억제하는 것 
- 좋고 나쁨의 기준이 무엇인가? 조직이 추구하는 가치
  - `규모와 시간 양쪽 측면에서 탄력적인 엔지니어링 환경이 지속되도록 하는 것`
- 코딩 어휘가 통일되면 엔지니어들은 `형식`보다 `내용`에 집중할 수 있다

### 규칙 만들기
- 무슨 규칙이 필요하지? 가 아니라 어떤 목표를 이루려 하지?
- 자율성과 규칙의 트레이드 오프
  - 내적동기를 이끄는 요소 : 자율성, 숙련, 의미
- 1. 규칙의 양을 최소화 한다
  - 자명한 규칙 배제
- 2. 읽는 사람에게 맞춘다
  - `쓰기에 간편한`보다 `읽기에 간단한`쪽에 가치를 둔다
  - 우리 목적은 `현 위치에서 추론하기` 입니다
- 3. 일관되어야 한다
  - 모든 지역별 연구소의 인터페이스가 동일하다 > 사소한 설정때문에 시간을 허비하는 일을 없앤다
  - 일관성 vs 자율성
  - 일관성이 주는 이점은 우리가 잃게되는 자유의 가치보다 훨씬 크다. 엔지니어가 더 많은 일을 적은 노력으로 수행할 수 있게 된다
  - 일관성이 규모를 확장하기 쉽게 도와준다 (도구 활용)
- 4. 실수를 유발하는 구조를 피한다
  - 구글은 코드베이스가 특정 전문가의 전유물이 아닌 모든 엔지니어의 작업 공간이 되길 원한다
- 5. 꼭 필요하면 예외를 허용한다
  - 일관성과 가독성을 희생해서라도 성능을 끌어올려야 할 때가 있다

### style-guide
- 어떤 내용이 포함되어야 하나?
  - 위험을 피하기 위한 규칙
  - 모범 사례를 적용하기 위한 규칙 : 주석, 네이밍, 포맷팅
  - 일관성을 보장하기 위한 규칙
  - 그리고, 이러한 결정 뒷받침하는 근거
- 일관성 
  - 파키슨의 사소함의 법칙 : 중요한 사안을 고민하는데는 아주 적은 시간만 들이면서 사소한 일에는 필요 이상의 시간과 노력을 들이는 현상. (별 차이가 없어서 더 합의를 못하는 팀 vs 별 차이가 없으니 그냥 정하자는 팀)
  - 하나를 선택함으로써 끝없는 논쟁에서 벗어나 더 중요한 일로 시선을 돌릴 수 있게 했다

### 규칙 적용하기
- 규칙을 강제하는 방법으로는 `교육과 훈련을 통한 사회적인 방법`과 `도구를 이용한 기술적인 방법`이 있다
- 도구활용은 확장성을 도와주지만, 사회적인 문제를 기술적인 문제로 해결하려 해서는 안된다.

> 생각해볼 것들
> - 우리는 spring api java style-guide를 만들어 보면 어떨까?
> - 구글의 style-guide (java, go, python) 공부해보기 어떨까? 
> - Error prone을 이용해 규칙 적용을 도구화 할 수 있을까?
> - 삼성에서 전체 적용되는 룰을 만들 수 있을까? 회사가 너무 커지지 않았을 때부터 만들어 온걸까?

## Chapter 9. 코드리뷰
> 핵심 메시지
> - 버그가 코드베이스로 침투하기 전에 잡아낸다
> - 심리적인 이점들은 시간이 흐르고 조직 규모가 커지면 큰 혜택이 된다

### 코드는 부채다
- 없어서는 안될 부채이긴 하겠으나 존재만으로 어느 순간 누군가에게 유지보수해야 할 대상이 되어버린다
- 마치 비행기의 연료처럼 비행기를 띄우려면 반드시 필요하지만, 그 자체가 하중을 늘려 부담으로 작용히죠
- 코드 리뷰는 전에 내린 설계를 번복하거나 재논의하는 자리여서는 안됩니다. 설계를 결정하는 데는 보통 시간이 걸립니다
- 전혀 새로운 코드를 리뷰하는 일이 뜬금없이 생겨서는 안 되듯이, 코드 리뷰 과정 자체를 기존 결정을 다시 논의할 기회로 보아서는 안됩니다

### 세가지 측면의 리뷰
- 다른 엔지니어 : 코드가 정확하고 유효한지
- 코드 소유자 : 승인 - 유지보수할 수 있을지, 기술부채를 안겨주는지
- 가독성 인증자 : 가독성 승인 (스타일 가이드에 맞는지)

> 구글에서는 Owners 파일이 왜 필요할까?
> - git 프로젝트 owner가 owner 아닌가? 단일 repo가 하나의 프로젝트란 뜻인가?
> - 한 프로젝트 내에서도 소유권을 나눠야 할 경우가 있나?

### 생각할 거리
- 코드리뷰는 코드의 유지보수와, 읽는속도 최적화와 쓰는속도의 트레이드오프
- 리뷰 프로세스를 날렵하게(확장성있게) 유지하기 위한 장치
  - 작은 변경, 빠른피드백, 최소리뷰어, 자동화
- 잘못되었다고 가정하기 전에 그렇게 처리하게 된 이유가 무엇인지부터 물어보는 것

> 생각해볼 것들
> - 우리가 부족한것들은 무엇이 있을까?

## Chapter 10. 문서자료
> 핵심 메시지
> - 문서자료는 시간이 흐르고 조직 규모가 커질수록 중요해진다
> - 문서자료 변경도 기존 개발자 워크플로에 통합되어야 한다 (문서자료를 코드처럼 취급)
> - 하나의 문서는 하나의 목적에 집중해야 한다
> - 문서자료는 자신이 아니라 독자를 위해 써야 한다 

### 문서자료란
- 엔지니어가 작업을 끝마치기 위해 작성해야 하는 모든 부수적인 텍스트

### 문서자료는 코드와 같다
- 꼭 따라야 하는 내부 정책과 규칙이 있다
- 버전 관리 시스템에 등록해 관리해야 한다
- 관리 책임자를 명시해야 한다
- 변경 시 (문서자료가 설명하는 코드와 함께) 리뷰를 거쳐야 한다
- 버그를 추적하듯 문제를 추적해야 한다
- 주기적으로 평가(혹은 테스트)를 받아야 한다
- 정확성이나 최신 정보 반영 여부 등을 측정해야 한다

### 위키에서 git으로
- 위키의 한계
  - 소유자가 없어서 많은 페이지가 오래된 정보를 그대로 담고 있다
  - 틀린 내용을 바로잡아줄 사람들이 없다
- 반대 의견
  - 정보를 자유롭게 올리지 못하고, 문서화 하는 장벽이 높아져서 문서자료 품질이 떨어질 것이다
- 효과
  - 개선됐다
  - 마크다운을 표준 문서 서식 언으로 도입했다
  - 코드안에 문서자료를 삽입해주는 프레임워크 g3doc (소스코드와 문서를 한 화면에서 볼 수 있다)
  - 문서자료를 코드와 비슷한 방식으로 유지보수한다 (버그 리포팅, CL에 문서자료 수정까지 포함, 리뷰받기) > 새로운 프로세스를 만들지 않고 기존 개발자 워크플로에 녹였다

### 독자 유형
- 경험수준
- 도메인 지식
- 목적
- 탐색자 vs 배회자
- `문서를 짧게 쓰려면 때로는 모든 정보를 담아 길게 쓴 다음 간명하게 편집하고 중복된 정보를 삭제하는 과정을 거쳐야 한다`

### 문서 자료 유형
- 주석 - api 주석, 구현 주석
- 설계문서
  - `중요한 프로젝트에 착수하기 전에 설계 문서부터 승인받아야 한다`
  - 표준 설계 문서 템플릿은 보안, 국제화, 스토리지 요구사항, 개인정보 보호 등 다양한 측면을 고려하도록 유도
  - `설계의 목표, 구현전략, 설계상의 핵심 선택들과 관련한 트레이드 오프를 명시`
- 튜토리얼
- 개념 설명 문서자료 : 주석으로는 부족한 경우 api나 시스템의 개요를 알려주는 개념 문서
- 랜딩 페이지

> 생각해볼 것들
> - 문서화에 우리가 적용해볼 것들은?
> - 위키에서 git으로
> - 소스트리에 문서 디렉토리를 추가하고 리뷰 받자
> - 스프린트 계획과 CL에 문서화를 넣자


## Chapter 11. 테스트 개요
> 핵심 메시지
> - 2000년대 초부터 소프트웨어 복잡도에 대응하기 위해 테스트 방식을 극적으로 진화시켰다
> - 테스트체계는 소프트웨어 개발의 핵심역량이다

### 테스트의 필요성
- 테스트가 갖을 수 있는 문제들
  - 느리기 비결정적임
  - 쉽게 깨짐
  - 명확하지 않음
- 나쁜 테스트는 아예 없는것만 못하다
- <구글 웹서버> 추가 기능의 80%가 버그로 롤백 (Change Failure Rate)
- `대부분의 소프트웨어는 사람이 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다`
- 그래서 테스트에서의 해법은 단 하나. 바로 '자동화' 뿐이다

### 건실한 자동화 테스트 문화
- 모두가 테스트를 작성하고 공유하도록 장려한다
- 테스트들을 정기적으로 실행한다
- 테스트가 실패하면 바로 바로 조치하도록 권장한다

### 테스트 코드가 주는 혜택
- 디버깅 감소
- 자신있게 변경
- 테스트 코드 자체가 더 나은 문서자료
- 더 단순한 리뷰
- 사려깊은 설계
- 고품질의 릴리즈를 빠르게

### 테스트 스위트 설계하기
- 테스트 케이스에는 두 가지 독립된 요소가 있다 : `크기` 와 `범위`
- 유연성 vs 느림 또는 비결정적
- 크기 : 테스트 케이스 하나를 실행하는 데 필요한 자원
  - 작은 테스트 : 하나의 프로세스에서 실행. 블로킹 호출 금지 (디스크, 네트워크)
  - 중간 테스트 : 한대의 기기에서 수행. 외부통신 금지. 여러프로세스 가능
  - 큰 테스트 : 여러 대의 기기 활용. 한정적으로만 사용. 설정을 검증. 개발 워크플로에서 분리 (빌드나 릴리즈 때만 수행)
  - 테스트 크기와 무관한 공통 특성
    - 밀폐되어야 한다.
    - 확인하려는 행위를 수행하는데 필요한 정보'만'을 포함해야 한다.
    - 테스트 자체를 검사해주는 테스트는 따로 없으므로 정확성이라는 중요한 검사는 사람이 직접 해야 한다. 따라서 복잡하지 않아야 한다.
- 범위 : 검증하려는 특정한 코드 경로
  - 단위테스트, 통합테스트, 기능테스트(종단간 테스트)
  - 딱히 실행할 수 없는 상황이 아니라면 실제 의존성을 끊지 않는 편을 선호한다.

* `테스트 대역은 강한 의존성을 가벼운 인프로세스 의존성으로 대체해주는 수단`
* `의도적으로 실패 상황을 만드는 테스트가 중요하다`
* `코드 커버리지는 작은 테스트에서만 측정하길 권한다. 큰 테스트는 커버리지 인플레이션을 일으킨다`
* `커버리지보다는 검사해야할 행위에 집중하자`

### 구글 의 특징
- 모든 코드를 모노리포에서 관리
- 매주 약 2천 5백만 라인이 변경
- 리포지터리 브랜치를 사용하는 팀이 거의 없다. 모든 변경은 헤드에 직접 커밋되어 변경즉시 모두가 볼 수 있다

### 구글 자동화 테스트를 전사에 뿌리내리게 한 원동력
- 오리엔테이션 수업
- 테스트 인증 프로그램 -> 자동화 방식으로 대체됨
- 화장실에서도 테스트

### 자동 테스트의 한계
- 모든 종류의 테스트를 다 자동화할 수는 없습니다 (검색품질 테스트)
- `탐색적 테스팅` : 검사대상을 마치 고장내야할 퍼즐로 취급

> 생각해볼 것들
> - ㅁㅁㅁ

## Chapter 12. 단위 테스트
> 핵심 메시지
> - 테스트의 목적은 1) 버그 예방, 2) 엔지니어의 생산성 향상

### 단위테스트는
- 빠르고 결정적이어서 수시로 수행하며 피드백 얻을 수 있다
- 작성하기 쉽다
- 커버리지를 높이기 좋다
- 실패시 원인 파악이 쉽다
- 문서자료, 예제코드 역할을 해준다

### 테스트 유지보수의 문제 두가지
- 깨지기 쉬운 테스트 (Brittle)
- 불명확한 테스트 (Unclear)

### 깨지기 쉬운 테스트를 예방하는 법
- Brittle test : 실제로는 버그가 없는 변경 때문에 실패하는 테스트
- 변하지 않는 테스트로 만들기 위해 노력하자
  - 순수 리팩터링, 새로운 기능 추가, 버그 수정 : 기존 테스트를 손볼일 없어야 함
  - 행위 변경 -> 시스템이 한 약속을 '의도적으로' 변경하는 케이스
- 공개 API를 이용해 테스트 (Private method는 테스트하지 말라)
  - 내부 구현을 위한 코드가 아닌 공개 API를 호출
  - 테스트가 시스템을 사용자와 똑같은 방식으로 사용하는 것
  - 소수의 다른 클래스를 보조하는 용도의 클래스는 독립 단위가 아니다
  - 소요자의 통제없이 누구나 접근할 수 있는 클래스는 직접 테스트해야하는 단위
  - 다방면으로 유용한 기능을 제공하도록 설계된 패키지나 클래스도 테스트 단위
- 상호작용이 아니라 상태를 테스트하자
  - 상태 테스트 vs 상호작용 테스트 -> mockito가 하는 것
  - 그래서 우리는 진짜 객체가 빠르고 결정적이라면 테스트 대역을 지양하고 진짜 객체를 사용

### 명확한 테스트 작성하기
- 명확한 테스트 : 존재 이유와 실패 원인을 엔지니어가 곧바로 알아차릴 수 있는 테스트
- 완전하고 간결하게
  - 완전한 테스트 : 결과에 도달하기까지의 논리를 읽는이가 이해하는데 필요한 모든 정보를 본문에 담고 있는 테스트
  - 간결한 테스트 : 관련 없는 정보를 포함하지 않는 테스트
- 메서드가 아니라 행위를 테스트하자
  - 테스트 구조를 대상 코드의 구조와 일치시킬 필요가 있나? (메서드 하나에 테스트 메서드 하나)
  - given/when/then을 활용
  - 메서드와 행위는 다대다 관계
  - 사소하지 않은 메서드는 대부분 여러가지 행위를 담당하며,
  - 어떤 행위는 여러 메서드를 연계해야 완성된다
  - 테스트의 구조는 행위가 부각되도록 (메서드 이름 > given/when/then > 실제 코드)
  - 테스트 이름은 검사하는 행위에 어울리게 짓자
    - 제품 코드보다 더 길게 상세하게 지어도 괜찮다.
    - 좋은 전략이 없으면 should로 시작하는 이름
  - 테스트에 논리를 넣지 말자
    - 연산자, 반복문, 조건문 등
    - 테스트 코드에서는 스마트한 로직보다 직설적인 코드를 고집해야 한다
  - 실패 메시지를 명확하게 작성하자
    - 원하는 결과, 실제 결과, 이때 건네진 입력값


### DRY가 아니라 DAMP!
- Don't Repeat Yourself
- Descriptive And Meaningful Phrase
- 단순하고 명료하게만 만들어준다면 테스트에서 다소의 중복은 괜찮습니다
- 테스트에서의 리팩터링은 반복을 줄이는 게 아니라 더 서술적이고 의미있게 하는 방향으로 이루어져야 한다